package com.customlauncher.app.service

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.graphics.PixelFormat
import android.os.Build
import android.os.IBinder
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.widget.FrameLayout
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import com.customlauncher.app.R
import com.customlauncher.app.ui.MainActivity
import android.app.KeyguardManager
import com.customlauncher.app.LauncherApplication

class TouchBlockService : Service() {
    
    private var blockView: View? = null
    private var screenshotBlockView: View? = null
    private var windowManager: WindowManager? = null
    private var isBlockingScreenshots: Boolean = false
    
    override fun onCreate() {
        super.onCreate()
        // Service should always be created when requested
        // The decision to block or not should be made in HiddenModeStateManager
        android.util.Log.d(TAG, "TouchBlockService created")
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        try {
            when (intent?.action) {
                ACTION_BLOCK_TOUCH -> {
                    // Always start touch blocking when requested
                    // HiddenModeStateManager handles the logic of when to call this
                    val blockScreenshots = intent.getBooleanExtra("block_screenshots", false)
                    if (DEBUG) android.util.Log.d(TAG, "Starting touch blocking, block screenshots: $blockScreenshots")
                    blockTouch(blockScreenshots)
                }
                ACTION_UNBLOCK_TOUCH -> {
                    unblockTouch()
                    // Stop service after unblocking
                    stopSelf()
                }
                else -> {
                    // Unknown action, stop service
                    stopSelf()
                }
            }
        } catch (e: Exception) {
            android.util.Log.e(TAG, "Error in onStartCommand", e)
            stopSelf()
        }
        return START_NOT_STICKY // Don't restart if killed
    }
    
    // Removed startForegroundService() method - we're not using foreground service
    // to avoid showing any notification in the status bar
    
    private fun blockTouch(blockScreenshots: Boolean = false) {
        try {
            isBlockingScreenshots = blockScreenshots
            
            // Service is only called when needed by HiddenModeStateManager
            if (blockView != null || screenshotBlockView != null) {
                if (DEBUG) android.util.Log.d(TAG, "Block view already exists")
                return
            }
            
            // Check permission first
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                if (!android.provider.Settings.canDrawOverlays(this)) {
                    android.util.Log.e(TAG, "No overlay permission")
                    return
                }
            }
            
            // Check if we need only screenshot blocking (touch blocking disabled)
            val preferences = LauncherApplication.instance.preferences
            val onlyScreenshotBlock = blockScreenshots && !preferences.blockTouchInHiddenMode
            
            if (DEBUG) android.util.Log.d(TAG, "Starting blocking - Screenshots: $blockScreenshots, Touch: ${!onlyScreenshotBlock}")
            
            // Get window manager safely
            windowManager = try {
                getSystemService(WINDOW_SERVICE) as WindowManager
            } catch (e: Exception) {
                android.util.Log.e(TAG, "Failed to get WindowManager", e)
                return
            }
        
        // Use highest priority overlay type
        val layoutFlag = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.O -> {
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
            }
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1 -> {
                @Suppress("DEPRECATION")
                WindowManager.LayoutParams.TYPE_SYSTEM_ERROR
            }
            else -> {
                @Suppress("DEPRECATION")
                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT
            }
        }
        
        // Flags to block all touch events completely on all screens
        val flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
                    WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or
                    WindowManager.LayoutParams.FLAG_FULLSCREEN or
                    WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS or
                    WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR
        
        // Add flags to show on lock screen and dismiss keyguard
        val finalFlags = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1 -> {
                flags or WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or
                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
            }
            else -> {
                @Suppress("DEPRECATION")
                flags or WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or
                        WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD or
                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
            }
        }
        
        // If only screenshot blocking is needed, create a minimal overlay
        if (onlyScreenshotBlock) {
            createScreenshotBlockingOverlay(layoutFlag)
            return
        }
        
        try {
            // Create blocking view with proper touch interception and multitouch blocking
            blockView = object : FrameLayout(this@TouchBlockService) {
                private var activeTouchId = -1
                
                override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {
                    ev?.let { event ->
                        // Block multitouch - only track first finger
                        when (event.actionMasked) {
                            MotionEvent.ACTION_DOWN -> {
                                // First finger down - remember its ID
                                activeTouchId = event.getPointerId(0)
                                android.util.Log.d("TouchBlockService", "First touch down, ID: $activeTouchId")
                            }
                            MotionEvent.ACTION_POINTER_DOWN -> {
                                // Additional finger down - block it completely
                                android.util.Log.d("TouchBlockService", "MULTITOUCH BLOCKED! Fingers: ${event.pointerCount}")
                                return true
                            }
                            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                                // Reset when all fingers up
                                activeTouchId = -1
                                android.util.Log.d("TouchBlockService", "Touch ended")
                            }
                            MotionEvent.ACTION_POINTER_UP -> {
                                // One finger lifted but not all - keep blocking
                                android.util.Log.d("TouchBlockService", "Pointer up, still blocking multitouch")
                                return true
                            }
                            MotionEvent.ACTION_MOVE -> {
                                // Block move events if multiple fingers detected
                                if (event.pointerCount > 1) {
                                    android.util.Log.d("TouchBlockService", "Multitouch move blocked")
                                    return true
                                } else {
                                    // Single touch move is allowed but still blocked
                                }
                            }
                            else -> {
                                // Handle other actions
                            }
                        }
                    }
                    // Block all touch events
                    android.util.Log.d("TouchBlockService", "Touch blocked: ${ev?.actionMasked}, pointers: ${ev?.pointerCount}")
                    return true
                }
                
                override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean {
                    // Also intercept at this level for extra safety
                    return true
                }
                
                override fun onTouchEvent(event: MotionEvent?): Boolean {
                    // Final level of touch interception
                    android.util.Log.d("TouchBlockService", "Touch blocked at onTouchEvent: ${event?.action}")
                    return true
                }
            }.apply {
                // Completely transparent overlay - можно сделать слегка видимым для отладки
                // setBackgroundColor(android.graphics.Color.argb(10, 0, 0, 0))
                setBackgroundColor(android.graphics.Color.TRANSPARENT)
                
                // Set touch listener as additional safeguard with multitouch blocking
                setOnTouchListener { _, event ->
                    if (event.pointerCount > 1) {
                        // Multitouch blocked
                        return@setOnTouchListener true
                    }
                    // Touch blocked
                    true
                }
                
                // Don't make focusable since window has FLAG_NOT_FOCUSABLE
                // This allows keyboard events to pass through
                isFocusable = false
                isFocusableInTouchMode = false
                isClickable = true
                isLongClickable = true
            }
            
            // Create params for full screen overlay
            // Add FLAG_SECURE if screenshot blocking is enabled
            val secureFlag = if (blockScreenshots) {
                WindowManager.LayoutParams.FLAG_SECURE
            } else {
                0
            }
            
            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                layoutFlag,
                // Добавляем FLAG_NOT_FOCUSABLE чтобы не блокировать клавиатуру
                // но оставляем FLAG_NOT_TOUCH_MODAL чтобы блокировать касания
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or
                WindowManager.LayoutParams.FLAG_FULLSCREEN or
                WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS or
                finalFlags or
                secureFlag, // Add FLAG_SECURE if needed
                PixelFormat.TRANSLUCENT
            ).apply {
                gravity = Gravity.TOP or Gravity.START
                x = 0
                y = 0
                
                // Ensure we cover the entire screen including system bars
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
                }
                
                // Покрываем весь экран включая статус бар и навигацию
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    fitInsetsTypes = 0 // Не учитываем insets, покрываем всё
                }
            }
            
            windowManager?.addView(blockView, params)
            if (DEBUG) android.util.Log.d(TAG, "Touch blocking overlay created and added - full screen coverage")
            
            // Don't create additional overlays for status and navigation bars
            // The main overlay should cover everything
            // This reduces memory usage and improves performance on weak devices
        } catch (e: Exception) {
            if (DEBUG) android.util.Log.e("TouchBlockService", "Failed to add overlay", e)
        }
        } catch (e: OutOfMemoryError) {
            if (DEBUG) android.util.Log.e(TAG, "Out of memory creating overlays", e)
            System.gc() // Force garbage collection
        } catch (e: Exception) {
            if (DEBUG) android.util.Log.e(TAG, "Unexpected error in blockTouch", e)
        }
    }
    
    // Removed additional overlay methods to reduce memory usage
    // The main overlay covers the entire screen including status bar and navigation
    
    private fun unblockTouch() {
        try {
            if (DEBUG) android.util.Log.d(TAG, "Removing touch blocking overlay...")
            
            // Remove overlay view immediately
            windowManager?.let { wm ->
                // Collect view if exists
                val viewToRemove = blockView
                
                // Clear reference immediately to prevent double removal
                blockView = null
                
                // Remove view if it exists
            }
            // Touch blocked
            true
        }

        // Don't make focusable since window has FLAG_NOT_FOCUSABLE
        // This allows keyboard events to pass through
        isFocusable = false
        isFocusableInTouchMode = false
        isClickable = true
        isLongClickable = true
    }

    // Create params for full screen overlay
    // Add FLAG_SECURE if screenshot blocking is enabled
    val secureFlag = if (blockScreenshots) {
        WindowManager.LayoutParams.FLAG_SECURE
    } else {
        0
    }

    val params = WindowManager.LayoutParams(
        WindowManager.LayoutParams.MATCH_PARENT,
        WindowManager.LayoutParams.MATCH_PARENT,
        layoutFlag,
        // Добавляем FLAG_NOT_FOCUSABLE чтобы не блокировать клавиатуру
        // но оставляем FLAG_NOT_TOUCH_MODAL чтобы блокировать касания
        WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
        WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or
        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
        WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or
        WindowManager.LayoutParams.FLAG_FULLSCREEN or
        WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS or
        finalFlags or
        secureFlag, // Add FLAG_SECURE if needed
        PixelFormat.TRANSLUCENT
    ).apply {
        gravity = Gravity.TOP or Gravity.START
        x = 0
        y = 0

        // Ensure we cover the entire screen including system bars
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
        }

        // Покрываем весь экран включая статус бар и навигацию
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            fitInsetsTypes = 0 // Не учитываем insets, покрываем всё
        }
    }

    windowManager?.addView(blockView, params)
    if (DEBUG) android.util.Log.d(TAG, "Touch blocking overlay created and added - full screen coverage")

    // Don't create additional overlays for status and navigation bars
    // The main overlay should cover everything
    // This reduces memory usage and improves performance on weak devices
} catch (e: Exception) {
    if (DEBUG) android.util.Log.e("TouchBlockService", "Failed to add overlay", e)
} catch (e: OutOfMemoryError) {
    if (DEBUG) android.util.Log.e(TAG, "Out of memory creating overlays", e)
    System.gc() // Force garbage collection
} catch (e: Exception) {
    if (DEBUG) android.util.Log.e(TAG, "Unexpected error in blockTouch", e)
}

private fun createScreenshotBlockingOverlay(layoutFlag: Int) {
    try {
        if (DEBUG) android.util.Log.d(TAG, "Creating screenshot-only blocking overlay")

        // Create a minimal 1x1 pixel view with FLAG_SECURE
        screenshotBlockView = View(this).apply {
            setBackgroundColor(0x00000000) // Fully transparent
        }

        // Create params for minimal overlay
        val params = WindowManager.LayoutParams(
            1, // 1 pixel width
            1, // 1 pixel height
            layoutFlag,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or
            WindowManager.LayoutParams.FLAG_SECURE, // Add FLAG_SECURE for screenshot blocking
            PixelFormat.TRANSLUCENT
        ).apply {
            gravity = Gravity.TOP or Gravity.START
            x = 0
            y = 0
        }

        windowManager?.addView(screenshotBlockView, params)
        if (DEBUG) android.util.Log.d(TAG, "Screenshot blocking overlay created (1x1 pixel with FLAG_SECURE)")

    } catch (e: Exception) {
        android.util.Log.e(TAG, "Failed to create screenshot blocking overlay", e)
    }
}

private fun unblockTouch() {
    try {
        blockView?.let {
            windowManager?.removeView(it)
            blockView = null
            if (DEBUG) android.util.Log.d(TAG, "Touch blocking overlay removed")
        }

        screenshotBlockView?.let {
            windowManager?.removeView(it)
            screenshotBlockView = null
            if (DEBUG) android.util.Log.d(TAG, "Screenshot blocking overlay removed")
        val resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android")
        if (resourceId > 0) {
            result = resources.getDimensionPixelSize(resourceId)
        }
        return result
    }
    
    private fun getStatusBarHeight(): Int {
        var result = 0
        val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")
        if (resourceId > 0) {
            result = resources.getDimensionPixelSize(resourceId)
        }
        return result
    }
    
    override fun onDestroy() {
        super.onDestroy()
        if (DEBUG) android.util.Log.d(TAG, "TouchBlockService onDestroy called")
        // Remove all overlays when service is destroyed
        unblockTouch()
        // Clear window manager reference
        windowManager = null
    }
    
    companion object {
        const val ACTION_BLOCK_TOUCH = "com.customlauncher.app.BLOCK_TOUCH"
        const val ACTION_UNBLOCK_TOUCH = "com.customlauncher.app.UNBLOCK_TOUCH"
        private const val NOTIFICATION_ID = 1001
        private const val TAG = "TouchBlockService"
        private const val DEBUG = false // Set to false for production
    }
}
